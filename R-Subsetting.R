# 构造子集

# -------------------------------------------------------------------------------------------- #
#  向量的子集
x <- 1:10
# 利用index获取元素
x[1]
# 获取指定位置的元素
x[1:5] # 返回一组logical向量 FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
x > 5 # 返回大于5的元素
# 根据x > 5的判断条件，获取符合条件的元素
x[x > 5]
# 获取大于3且小于7的元素
x[x > 3 & x < 7]
# 获取小于3或大于6的元素
x[x < 3 | x > 6]

# 利用名字获取元素
y <- 1:4
names(y) <- c("lucy", "tom", "chloe", "sam")
y[1]
y["lucy"]

# -------------------------------------------------------------------------------------------- #
# 矩阵的子集
data <- c("lucy", "tom", "chloe", "sam", "peter", "jack","tim", "john", "tony")
m <- matrix(data, nrow = 3, ncol = 3)
# 获取第1行，第1列的元素
# 返回的是一个向量
m[1,1]
class(m)
# 参数drop = FALSE，返回1个1行1列矩阵
m[1, 1, drop = FALSE]
class(m)
# 获取某行，某列的所有元素
m[1,]
m[,2]
# 获取某列或某行的多个元素
m[1,c(2,3)] # 第1行，第2，3个元素
m[c(1,3),2] # 第2列，第1，3个元素

# -------------------------------------------------------------------------------------------- #
# 数据框的子集 
df <- data.frame(v1 = 1:6, v2 = 7:12, v3 = 13:18)
# 替换数据框中某列的元素
df$v1[c(2,6)] <- c(20, 24) # 将第1列的第2，6个元素，替换成20，24
# 获取某列的所有元素
df$v1 # $name
df[,2] # [, index]
df[,"v3"] # [, name]
# 获取第1列大于等于3 且 第2列小于等于11的元素
df[df$v1 >= 3 & df$v2 <= 11, ]
# 获取第1列大于3的所有元素
df[df$v1 > 3, ] # df$v1 > 3 返回的结果为 FALSE FALSE FALSE  TRUE  TRUE  TRUE
df[which(df$v1 > 3), ] # which(df$v1 > 3) 返回的结果为所有符合条件的行数（2，4，5，6）
# 利用subset()函数获取子集
subset(df, df$v1 >= 3 & df$v2 <= 10)

# -------------------------------------------------------------------------------------------- #
# 列表的子集
l <- list(id = c(1, 2, 3, 4), name = c("lucy", "tom", "jack", "sam"), gender = c("female", "male", "male", "male"))
# 获取列表中的id
l[1] # [index]
l["id"] # [name]
l$id # $name
# 获取列表中id的内容
l[[1]]
l[["id"]]
# []:获取列表中第2，3个向量
l[c(2, 3)] 
# [[]]:获取列表中第2个向量中的第4个元素
l[[c(2, 4)]] # "sam"
l[[c(3, 4)]] # "male"
# 不完全匹配
l2 <- list(asdfghjkl = 1:10)
l2$a
# 参数exact = FALSE，关闭精确匹配
l2[["a", exact = FALSE]]
l3 <- list(asd = 1:6, b = 1:3, ads = 1:10)
# 因为有两个a开头的向量名称，所以无法进行不完全匹配
l3$as

# -------------------------------------------------------------------------------------------- #
# 缺失值的处理 missing value
mv <- c(1, NA, 2, NA, 3)
# 获取过滤缺失值后的向量
mv[!is.na(mv)]
# 获取对应位置都不为缺失值的元素
mv2 <- c(101, NA, 102, NA, 3)
mv3 <- c("a", NA, NA, "b", NA)
# complete.cases()，比对传入的两个向量，对应位置都不为NA的为TRUE，否则为FALSE
notNA <- complete.cases(mv2, mv3)
mv2[notNA] 
mv3[notNA]

# -------------------------------------------------------------------------------------------- #
# 利用library(package name)函数加载package
library(datasets)
# 利用head(dataset name)显示前6行的数据
head(airquality)
# 过滤airquality数据框中，有NA的数据
g <- complete.cases(airquality)
# 获取过滤掉NA的数据，并且显示出前7行数据
airquality[g, ][1:7, ]

# -------------------------------------------------------------------------------------------- #
# 向量化操作
v <- 1:5
v1 <- 6:10
# 加减乘除
v + v1
v - v1
v * v1
v / v1

m1 <- matrix(1:6, nrow = 3, ncol = 2)
m2 <- matrix(1:6, nrow = 2, ncol = 3)

m1 + m2
m1 - m2
m1 * m2
m1 / m2

# 矩阵乘
# 返回一个m1.nrow * m2.ncol的新矩阵
# m1的每1列的元素分别 * m2的每1行的元素
# [1,1] = 1 * 1 + 4 * 2 = 9   [2,1] = 1 * 3 + 4 * 4 = 19  [3,1] = 1 * 5 + 4 * 6 = 29
# [2,1] = 2 * 1 + 5 * 2 = 12  [2,2] = 2 * 3 + 5 * 4 = 26  [3,2] = 2 * 5 + 5 * 6 = 40
# [3,1] = 3 * 1 + 6 * 2 = 15  [2,3] = 3 * 3 + 6 * 4 = 33  [3,3] = 3 * 5 + 6 * 6 = 51
m1 %*% m2


